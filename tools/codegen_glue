#!/usr/bin/env python

from string import Template
import os

import pycparser

# Parse a single struct out of a C or C++ header file.
# The struct must be Plain Old Data.
# We keep it simple:
# No nesting, unions, arrays
def parse_header_file(filename):
    from pycparser import parse_file
    from pycparser.c_ast import NodeVisitor

    ast = parse_file(filename, use_cpp=True)

    class StructVisitor(NodeVisitor):
        def __init__(self):
            self.values = []
        def visit_Struct(self,node):
            self.values.append(node)

    v = StructVisitor()
    v.visit(ast)
    assert len(v.values)==1 # There should only be one structure in the file
    s = v.values[0]
    structName = s.name

    memberNames = []
    memberTypes = []
    for c in s.children():
        decl = c[1]
        #print decl.name
        #print decl.children()
        chilrens = decl.children()
        assert len(chilrens)==1
        assert chilrens[0][0] == 'type'
        t = chilrens[0][1]
        typeString = t.children()[0][1].names[0] # i.e. 'double'
        memberNames.append(decl.name)
        memberTypes.append(typeString)
        
    return structName, memberNames, memberTypes


def codegen_typekit(structName, memberNames, headerFilename):
    typekitTemplate = """/* WARNING!!! This file was code generated by codegen_typekit!!! */
#include "${sourceHeaderFilename}"

#include <rtt/types/StructTypeInfo.hpp>
#include <rtt/types/TypekitPlugin.hpp>

namespace boost
{
	namespace serialization
	{
		template< class Archive >
		void serialize(Archive& a, ${structName}& mht, unsigned int)
		{
			using boost::serialization::make_nvp;
${memberSerializationSnippet}
			
		}
	}
}

struct ${structName}TypeInfo
	: public RTT::types::StructTypeInfo< ${structName} >
{
	${structName}TypeInfo()
		: RTT::types::StructTypeInfo< ${structName} >( "${structName}" )
	{}
};

class ${structName}Typekit
	: public RTT::types::TypekitPlugin
{
public:
	virtual std::string getName();
	virtual bool loadTypes();
	virtual bool loadConstructors();
	virtual bool loadOperators();
};

std::string ${structName}Typekit::getName() { return "${structName}Typekit"; }

bool ${structName}Typekit::loadTypes()
{
	RTT::types::Types()->addType(new ${structName}TypeInfo());
	return true;
}

bool ${structName}Typekit::loadConstructors() { return true; }
bool ${structName}Typekit::loadOperators() { return true; }

ORO_TYPEKIT_PLUGIN( ${structName}Typekit )
"""
    # Generate lines of code like
    #      a & make_nvp("gyro_x", mht.gyro_x);
    t = '\t\t\ta & make_nvp("${memberName}", mht.${memberName});'
    snippets = [Template(t).substitute(memberName=memberName) for memberName in memberNames]
    memberSerializationSnippet = '\n'.join(snippets)
    
    sourceHeaderFilename = os.path.basename(headerFilename)
    generatedFile = Template(typekitTemplate).substitute(sourceHeaderFilename=sourceHeaderFilename,
                                                         structName=structName,
                                       memberSerializationSnippet=memberSerializationSnippet)

    generatedFilename = structName + 'Typekit.cpp'
    fd = open(generatedFilename,'w')
    fd.write(generatedFile)
    fd.close()



# Generate a flat google protobuf .proto definition file
def codegen_proto_file(structName, memberNames, memberTypes):
    # Generate lines like "required float theta = 1;"
    def member_snippet(tyype, name, index):
        return '\trequired ' + tyype + \
                ' ' + name + ' = ' + str(index) + ';\n'
    membersSnippet = '' 
    for i in xrange(len(memberNames)):
        membersSnippet += member_snippet(memberTypes[i], 
                                        memberNames[i], 
                                        i) 
    protoTemplate="""package ${structName}Proto;

message ${structName}Msg
{
${membersSnippet}
}
"""
    generatedFile = Template(protoTemplate).substitute(
        membersSnippet=membersSnippet,
        structName=structName)

    generatedFilename = structName + 'Telemetry.proto'
    fd = open(generatedFilename,'w')
    fd.write(generatedFile)
    fd.close()



if __name__ == '__main__':
    import sys
    import argparse
    p = argparse.ArgumentParser(description="Generate orocos->protobuf->zeromq glue code")
    p.add_argument("headerFilename", help="A file containing a single C or C++ struct declaration.  Methods, nesting, unions are NOT currently supported!")
    p.add_argument('-t', '--typekit', action='store_true', help="generate a .cpp file containing an orocos typekit for the structure")
    p.add_argument('-p', '--protobuf', action='store_true', help="generate a .proto file for a protobuf with the same members as the structure")
    p.add_argument('--verbose', action='store_true', help="Print more information during processing")
    args = p.parse_args()
    print args
    print args.headerFilename

    headerFilename=args.headerFilename

    structName, memberNames, memberTypes = parse_header_file(headerFilename)
    if args.verbose:
        print "Successfully parsed struct " + structName + " from file " + headerFilename
        print "Found members: \n" + '\n'.join(memberNames)

    if args.typekit:
        if args.verbose:
            print "Generating typekit..."
        codegen_typekit(structName, memberNames, headerFilename)
        if args.verbose:
            print "Done"

    if args.protobuf:
        if args.verbose:
            print "Generating protobuf .proto file..."
        codegen_proto_file(structName, memberNames, memberTypes)



