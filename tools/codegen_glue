#!/usr/bin/env python

from string import Template, lower
import os

import pycparser

# Parse a single struct out of a C or C++ header file.
# The struct must be Plain Old Data.
# We keep it simple:
# No nesting, unions, arrays
def parse_header_file(filename):
    from pycparser import parse_file
    from pycparser.c_ast import NodeVisitor

    ast = parse_file(filename, use_cpp=True)

    class StructVisitor(NodeVisitor):
        def __init__(self):
            self.values = []
        def visit_Struct(self,node):
            self.values.append(node)

    v = StructVisitor()
    v.visit(ast)
    assert len(v.values)==1 # There should only be one structure in the file
    s = v.values[0]
    structName = s.name

    memberNames = []
    memberTypes = []
    for c in s.children():
        decl = c[1]
        #print decl.name
        #print decl.children()
        chilrens = decl.children()
        assert len(chilrens)==1
        assert chilrens[0][0] == 'type'
        t = chilrens[0][1]
        typeString = t.children()[0][1].names[0] # i.e. 'double'
        memberNames.append(decl.name)
        memberTypes.append(typeString)
        
    return structName, memberNames, memberTypes


def codegen_typekit(structName, memberNames, headerFilename):
    typekitTemplate = """/* WARNING!!! This file was code generated by codegen_typekit!!! */
#include "${sourceHeaderFilename}"

#include <rtt/types/StructTypeInfo.hpp>
#include <rtt/types/TypekitPlugin.hpp>

namespace boost
{
	namespace serialization
	{
		template< class Archive >
		void serialize(Archive& a, ${structName}& mht, unsigned int)
		{
			using boost::serialization::make_nvp;
${memberSerializationSnippet}
			
		}
	}
}

struct ${structName}TypeInfo
	: public RTT::types::StructTypeInfo< ${structName} >
{
	${structName}TypeInfo()
		: RTT::types::StructTypeInfo< ${structName} >( "${structName}" )
	{}
};

class ${structName}Typekit
	: public RTT::types::TypekitPlugin
{
public:
	virtual std::string getName();
	virtual bool loadTypes();
	virtual bool loadConstructors();
	virtual bool loadOperators();
};

std::string ${structName}Typekit::getName() { return "${structName}Typekit"; }

bool ${structName}Typekit::loadTypes()
{
	RTT::types::Types()->addType(new ${structName}TypeInfo());
	return true;
}

bool ${structName}Typekit::loadConstructors() { return true; }
bool ${structName}Typekit::loadOperators() { return true; }

ORO_TYPEKIT_PLUGIN( ${structName}Typekit )
"""
    # Generate lines of code like
    #      a & make_nvp("gyro_x", mht.gyro_x);
    t = '\t\t\ta & make_nvp("${memberName}", mht.${memberName});'
    snippets = [Template(t).substitute(memberName=memberName) for memberName in memberNames]
    memberSerializationSnippet = '\n'.join(snippets)
    
    sourceHeaderFilename = os.path.basename(headerFilename)
    generatedFile = Template(typekitTemplate).substitute(sourceHeaderFilename=sourceHeaderFilename,
                                                         structName=structName,
                                       memberSerializationSnippet=memberSerializationSnippet)

    generatedFilename = structName + 'Typekit.cpp'
    fd = open(generatedFilename,'w')
    fd.write(generatedFile)
    fd.close()



# Generate a flat google protobuf .proto definition file
def codegen_proto_file(structName, memberNames, memberTypes):
    # Generate lines like "required float theta = 1;"
    def member_snippet(tyype, name, index):
        return '\trequired ' + tyype + \
                ' ' + name + ' = ' + str(index) + ';\n'
    membersSnippet = '' 
    for i in xrange(len(memberNames)):
        membersSnippet += member_snippet(memberTypes[i], 
                                        memberNames[i], 
                                        i+1) 
    protoTemplate="""package ${structName}Proto;

message ${structName}Msg
{
${membersSnippet}
}
"""
    generatedFile = Template(protoTemplate).substitute(
        membersSnippet=membersSnippet,
        structName=structName)

    generatedFilename = structName + 'Telemetry.proto'
    fd = open(generatedFilename,'w')
    fd.write(generatedFile)
    fd.close()

def codegen_protobuf_bridge(structName, memberNames, headerFileName):
    # Generate lines like "	msg.set_winchspeedsmoothed( data.winchSpeedSmoothed );"
    def member_snippet(tyype, name, index):
        return '\tmsg.set_' + lower(name) + '( data.' + name + ' );\n'
    membersSnippet = '' 
    for i in xrange(len(memberNames)):
        if (memberNames[i] != "ts_trigger") and (memberNames[i] != "ts_elapsed"):
            membersSnippet += member_snippet(memberTypes[i], 
                                        memberNames[i], 
                                        i+1) 

    componentTemplate="""// WARNING THIS WAS AUTOGENERATED BY codegen_glue!!! 

// OROCOS headers
#include <rtt/TaskContext.hpp>
#include <rtt/Port.hpp>
#include <rtt/Component.hpp>
#include <rtt/Property.hpp>

// ZMQ header
#include <zhelpers.hpp>

// Protobuf
#include <google/protobuf/stubs/common.h>

// Header with the original C++ struct definition
#include "${headerFilename}"

// Protobuf header, autogenerated
#include "${structName}Telemetry.pb.h"

class ${structName}Telemetry
: public RTT::TaskContext
{
	public:

		${structName}Telemetry(std::string name);
		~${structName}Telemetry(){};

		/// Configuration hook.
		virtual bool configureHook( );
		/// Start hook.
		virtual bool startHook( );
		/// Update hook.
		virtual void updateHook( );
		/// Stop hook.
		virtual void stopHook( );
		/// Cleanup hook.
		virtual void cleanupHook( );

	protected:

		void fill();

		RTT::InputPort< ${structName} > portData;
		${structName} data;

		${structName}Proto::${structName}Msg msg;

		std::string port;

		uint64_t startTime;

	private:

		// TODO make those guys shared pointers
		zmq::context_t* zContext;
		zmq::socket_t*  zSocket;

		std::string raw;
};

${structName}Telemetry::${structName}Telemetry(std::string name)
: RTT::TaskContext(name, PreOperational),
	startTime( 0 )
{
	addPort("msgData", portData)
		.doc("Message data");

	addProperty("startTime", startTime)
		.doc("Zero-time time-stamp");

	addProperty("port", port)
		.doc("Port for publishing the data");

	zContext = NULL;
	zSocket = NULL;
}

bool ${structName}Telemetry::configureHook()
{
	GOOGLE_PROTOBUF_VERIFY_VERSION;

	zContext = new zmq::context_t( 1 );

	//
	// Execute a test run to reveal the message size
	// and reserve memory for transport buffer
	//
	fill();
	raw.resize(msg.ByteSize(), 0);

	if (port.empty() == true)
		return false;

	return true;
}

bool ${structName}Telemetry::startHook()
{
	zSocket = new zmq::socket_t(*zContext, ZMQ_PUB);
	zSocket->bind( port.c_str() );

	return true;
}

void ${structName}Telemetry::updateHook()
{
	if (portData.read( data ) == RTT::NewData)
	{
		// Fill in the protobuf
		fill();
		// Serialize data
		msg.SerializeToString( &raw );
		// Transmit serialized data
		if (s_send(*zSocket, raw) == false)
			exception();
	}
}

void ${structName}Telemetry::stopHook()
{
	if (zSocket != NULL)
		delete zSocket;
}

void ${structName}Telemetry::cleanupHook()
{
	google::protobuf::ShutdownProtobufLibrary();

	if (zContext != NULL)
		delete zContext;
}

void ${structName}Telemetry::fill()
{
${membersSnippet}

	msg.set_ts_trigger( (double)((uint64_t)data.ts_trigger - startTime) * 1e-9);
	msg.set_ts_elapsed( data.ts_elapsed );
}

ORO_CREATE_COMPONENT_LIBRARY()
ORO_LIST_COMPONENT_TYPE( ${structName}Telemetry )
//ORO_CREATE_COMPONENT( ${structName}Telemetry )
"""
    generatedFile = Template(componentTemplate).substitute(
        membersSnippet=membersSnippet,
        structName=structName,
        headerFilename=headerFilename)

    generatedFilename = structName + 'Telemetry.cpp' 
    fd = open(generatedFilename,'w')
    fd.write(generatedFile)
    fd.close()



if __name__ == '__main__':
    import sys
    import argparse
    p = argparse.ArgumentParser(description="Generate orocos->protobuf->zeromq glue code")
    p.add_argument("headerFilename", help="A file containing a single C or C++ struct declaration.  Methods, nesting, unions are NOT currently supported!")
    p.add_argument('-t', '--typekit', action='store_true', help="generate a .cpp file containing an orocos typekit for the structure")
    p.add_argument('-p', '--protobuf', action='store_true', help="generate a .proto file for a protobuf with the same members as the structure")
    p.add_argument('-b', '--bridge', action='store_true', help="generate an orocos component that takes the struct on an input port (relies on the typekit), serializes it (using the generated protobuf), and sends it over the network using zeromq")
    p.add_argument('--verbose', action='store_true', help="Print more information during processing")
    args = p.parse_args()

    headerFilename=args.headerFilename

    structName, memberNames, memberTypes = parse_header_file(headerFilename)
    if args.verbose:
        print "Successfully parsed struct " + structName + " from file " + headerFilename
        print "Found members: \n" + '\n'.join(memberNames)

    if args.typekit:
        if args.verbose:
            print "Generating typekit..."
        codegen_typekit(structName, memberNames, headerFilename)
        if args.verbose:
            print "Done"

    if args.protobuf:
        if args.verbose:
            print "Generating protobuf .proto file..."
        codegen_proto_file(structName, memberNames, memberTypes)

    if args.bridge:
        if args.verbose:
            print "Generating protobuf bridge component .cpp file..."
        codegen_protobuf_bridge(structName, memberNames, headerFilename)



