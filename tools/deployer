#!/bin/bash

cwd="$(pwd)"
abspath=$(dirname "$(cd "${0%/*}" 2>/dev/null; echo "$PWD"/"${0##*/}")")
cmd=$(basename $0)

# Search for an orocos path settings file.  This file is a list of relative
# paths to be added to the RTT_COMPONENT_PATH environment variable.  This makes
# it possible to ship code that builds and runs without forcing the user to
# manually set up environment environment variables.
# (Or rely on another software like ROS to do the forcing)
MAGIC_FILE_NAME=.rtt_component_path
scan_dir()
{
	if [ `find "$x" -maxdepth 1 -name $MAGIC_FILE_NAME` ]
	then 
		for p in `cat "$x"/$MAGIC_FILE_NAME`
		do
			export RTT_COMPONENT_PATH=${RTT_COMPONENT_PATH}:$x/$p
		done
		break;
	fi
}
x=$cwd
scan_dir
until [ "$x" == "/" ]
do 
	x=`dirname "$x"`
	scan_dir
done

# Figure out what suffix the build system stuck
# in the ~actual deployer's filename so we can run it.
if [ -z "${OROCOS_TARGET}" ]; then
    possibilities=$(echo $abspath/$cmd-*)
    if [ -z "$possibilities" -o ! -f "$possibilities" ]; then
	echo "You have not set the OROCOS_TARGET environment variable. I need it to know which target to run."
	echo "You can set it by doing for example: 'export OROCOS_TARGET=gnulinux' in your .bashrc"
	echo " or before you run this script."
	exit 1
    fi
    cmd=$possibilities
else
    cmd=$abspath/$cmd-${OROCOS_TARGET}
fi

# If there is only a single argument, and it is a .ops script,
# automatically add the -s flag so that it is deployed.
# This enables users to make .ops files executable with:
#  a hash-bang line at the top of their .ops file, i.e.:
#        #!/usr/bin/env deployer
# Without this, users could still use:
#        #!/usr/local/bin/deployer -c
# , but that hard-codes the path to the deployer in their .ops script.
MISSING_START_FLAG=
if [ $# == 1 ]; then
	if [ $(echo $1 |cut -b1) != "-" ]; then
		filename=$(basename "$1")
		extension="${filename##*.}"
		if	[ $extension = "ops" ]; then
			MISSING_START_FLAG="-s"
		fi
	fi
fi

$cmd $MISSING_START_FLAG $*
