/// Base class
#include "TelemetryBase.hpp"
/// Custom data type used by OROCOS
#include "types/LEDTrackerDataType.hpp"
/// Protobuf header, autogenerated
#include "LEDTrackerTelemetry.pb.h"
/// LED tracker "conf" files
#include "CameraArray.hpp"
#include "BlobExtractor.hpp"

class LEDTrackerTelemetry
  : public TelemetryBase<LEDTrackerDataType, LEDTrackerProto::LEDTrackerMsg>
{
  typedef TelemetryBase<LEDTrackerDataType, LEDTrackerProto::LEDTrackerMsg> Base;

public:
  LEDTrackerTelemetry(std::string name)
    : Base( name )
  {
    // Here we just add as much frames as configured
    for (unsigned el = 0; el < CAMERA_COUNT; ++el)
      msg.add_frames();
  }

  ~LEDTrackerTelemetry()
  {}

protected:

  virtual void fill();

};

using namespace RTT;

void LEDTrackerTelemetry::fill()
{
  unsigned el = 0;

  if (data.positions.size() != CAMERA_COUNT * LED_COUNT * 2)
  {
	  log( Debug ) << "Data size is wrong: " << data.positions.size() << endlog();
	  return;
  }

  for (unsigned cnt = 0; cnt < CAMERA_COUNT; ++cnt)
  {
    LEDTrackerProto::LEDTrackerMsg_Frame* frame = msg.mutable_frames( cnt );

    frame->mutable_r()->set_u( data.positions[ el++ ] );
    frame->mutable_r()->set_v( data.positions[ el++ ] );

    frame->mutable_g()->set_u( data.positions[ el++ ] );
    frame->mutable_g()->set_v( data.positions[ el++ ] );

    frame->mutable_b()->set_u( data.positions[ el++ ] );
    frame->mutable_b()->set_v( data.positions[ el++ ] );
  }

  msg.set_ts_trigger(data.ts_trigger * 1e-9);
  msg.set_ts_elapsed( data.ts_elapsed );
}

ORO_CREATE_COMPONENT_LIBRARY()
ORO_LIST_COMPONENT_TYPE( LEDTrackerTelemetry )
